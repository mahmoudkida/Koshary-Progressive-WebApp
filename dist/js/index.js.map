{"version":3,"sources":["indexdbhelper.js","dbhelper.js","swhelper.js","index.js"],"names":["IndexDBHelper","navigator","serviceWorker","idb","open","upgradeDb","oldVersion","createObjectStore","keyPath","createIndex","autoIncrement","Promise","resolve","restaurants","callback","arguments","length","undefined","openDatabase","then","db","tx","transaction","store","objectStore","forEach","restaurant","put","complete","index","getAll","json","id","find","i","reviews","review","restraintReviewArray","filter","restaurantId","offlineReviews","ReviewId","delete","offlineFavorites","favoriteRestaurantId","fetchReviewOffline","error","reviewId","DBHelper","postRestaurantReview","deleteReviewOffline","fetchFavoriteOffline","favoriteRestaurants","favoriteRestaurant","toggleRestaurantFavorite","deleteFavoriteOffline","fetch","DATABASE_URL","response","storeRestaurants","catch","ex","fetchRestaurants","fetchRestaurantById","storeForOffline","is_favorite","method","postFavoriteOffline","cuisine","results","r","cuisine_type","neighborhood","neighborhoods","map","v","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","storeReviews","fetchReviews","body","addedReview","Object","assign","postReview","postReviewOffline","photograph","google","maps","Marker","position","latlng","title","name","url","urlForRestaurant","animation","Animation","DROP","IndexController","this","_registerServiceWorker","prototype","refreshing","indexController","register","reg","controller","waiting","_updateReady","installing","_trackInstalling","addEventListener","window","location","reload","event","console","log","data","msg","worker","state","confirm","postMessage","action","swController","markers","document","getAllRestaurants","fetchCuisines","fetchNeighborhoods","self","fillNeighborhoodsHTML","select","reviewStore","option","createElement","value","append","fillCuisinesHTML","getElementById","innerHTML","initMap","Map","zoom","center","lat","scrollwheel","classList","add","addMarkersToMap","initStaticMap","staticMapURL","imageConrtainer","offsetWidth","offsetHeight","lng","querySelector","setAttribute","fetchRestaurantByCuisineAndNeighborhood","resetRestaurants","fillRestaurantsHTML","updateRestaurants","cSelect","idIndex","ul","createRestaurantHTML","setTimeout","li","imageSrc","imageUrlForRestaurant","image","className","src","alt","picture","dataContainer","href","address","more","addTofavoriteButton","addRestaurantToFavorite","btn","dataset","alert","remove","marker","mapMarkerForRestaurant","addListener","push","changeAriaValue","that"],"mappings":"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","file":"index.js","sourcesContent":["/**\r\n * indexdb helper.\r\n */\r\n\r\n\r\nclass IndexDBHelper {\r\n    static openDatabase() {\r\n        // If the browser doesn't support service worker,\r\n        // we don't care about having a database\r\n        if (!navigator.serviceWorker) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return idb.open('koshary', 4, upgradeDb => {\r\n            switch (upgradeDb.oldVersion) {\r\n                case 0:\r\n                    let restaurantStore = upgradeDb.createObjectStore('restaurants', {\r\n                        keyPath: 'id'\r\n                    });\r\n                    restaurantStore.createIndex('id', 'id');\r\n                case 1:\r\n                    let reviewStore = upgradeDb.createObjectStore('reviews', {\r\n                        keyPath: 'id'\r\n                    });\r\n                    reviewStore.createIndex('id', 'id');\r\n                case 2:\r\n                    let offlineReview = upgradeDb.createObjectStore('offline-reviews', {\r\n                        keyPath: \"id\",\r\n                        autoIncrement: true\r\n                    });\r\n                case 3:\r\n                    let offlineRestaurantFavorite = upgradeDb.createObjectStore('offline-favorite', {\r\n                        keyPath: \"id\"\r\n                    });\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n\r\n    static storeRestaurants(restaurants, callback = () => {}) {\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('restaurants', 'readwrite');\r\n            let store = tx.objectStore('restaurants');\r\n            restaurants.forEach(function (restaurant) {\r\n                store.put(restaurant);\r\n            });\r\n            tx.complete;\r\n        }).then(() => {\r\n            callback(null, restaurants);\r\n        });\r\n    }\r\n\r\n    static fetchRestaurants(callback) {\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('restaurants', 'readwrite');\r\n            let store = tx.objectStore('restaurants');\r\n            let idIndex = store.index(\"id\");\r\n            return idIndex.getAll();\r\n        }).then((json) => {\r\n            callback(null, json);\r\n        });\r\n    }\r\n    static fetchRestaurantById(id, callback = () => {}) {\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('restaurants', 'readwrite');\r\n            let store = tx.objectStore('restaurants');\r\n            let idIndex = store.index(\"id\");\r\n            return idIndex.getAll();\r\n        }).then((restaurants) => {\r\n            let restaurant = restaurants.find((restaurant, i) => restaurant.id == id);\r\n            callback(null, restaurant);\r\n        });\r\n\r\n    }\r\n\r\n    static toggleRestaurantFavorite(restaurant, callback = () => {}) {\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('restaurants', 'readwrite');\r\n            let store = tx.objectStore('restaurants');\r\n            store.put(restaurant);\r\n            return tx.complete;\r\n        }).then(() => {\r\n            callback(null, restaurant);\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n    static storeReviews(reviews, callback = () => {}) {\r\n        //cach reviews in indexdb\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('reviews', 'readwrite');\r\n            let store = tx.objectStore('reviews');\r\n            reviews.forEach(function (review) {\r\n                store.put(review);\r\n            });\r\n            return tx.complete;\r\n        }).then(() => {\r\n            callback(null, reviews);\r\n        });\r\n\r\n    }\r\n\r\n    static fetchReviews(id, callback = () => {}) {\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('reviews', 'readwrite');\r\n            let store = tx.objectStore('reviews');\r\n            let idIndex = store.index(\"id\");\r\n            return idIndex.getAll;\r\n        }).then((reviews) => {\r\n            let restraintReviewArray = {};\r\n            if (id) {\r\n                restraintReviewArray = reviews.filter((review, i) => review[\"restaurant_id\"] == restaurantId);\r\n            } else {\r\n                restraintReviewArray = reviews;\r\n            }\r\n            callback(null, restraintReviewArray);\r\n        });\r\n    }\r\n    static postReview(review, callback = () => {}) {\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('reviews', 'readwrite');\r\n            let store = tx.objectStore('reviews');\r\n            store.put(review);\r\n            return tx.complete;\r\n        }).then(() => {\r\n            callback(null, review);\r\n        });\r\n    }\r\n\r\n    static postReviewOffline(review, callback = () => {}) {\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('offline-reviews', 'readwrite');\r\n            let store = tx.objectStore('offline-reviews');\r\n            store.put(review);\r\n            return tx.complete;\r\n        }).then(() => {\r\n            callback(null, review);\r\n        });\r\n    }\r\n\r\n    static fetchReviewOffline(callback) {\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('offline-reviews', 'readwrite');\r\n            let store = tx.objectStore('offline-reviews');\r\n            return store.getAll();\r\n        }).then((offlineReviews) => {\r\n            callback(null, offlineReviews);\r\n        });\r\n    }\r\n\r\n    static deleteReviewOffline(ReviewId, callback = () => {}) {\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('offline-reviews', 'readwrite');\r\n            let store = tx.objectStore('offline-reviews');\r\n            return store.delete(ReviewId);\r\n        }).then(() => {\r\n            callback(null);\r\n        });\r\n    }\r\n    static postFavoriteOffline(restaurant, callback = () => {}) {\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('offline-favorite', 'readwrite');\r\n            let store = tx.objectStore('offline-favorite');\r\n            store.put(restaurant);\r\n            return tx.complete;\r\n        }).then(() => {\r\n            callback(null, restaurant);\r\n        });\r\n    }\r\n    static fetchFavoriteOffline(callback) {\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('offline-favorite', 'readwrite');\r\n            let store = tx.objectStore('offline-favorite');\r\n            return store.getAll();\r\n        }).then((offlineFavorites) => {\r\n            callback(null, offlineFavorites);\r\n        });\r\n    }\r\n    static deleteFavoriteOffline(favoriteRestaurantId, callback = () => {}) {\r\n        IndexDBHelper.openDatabase().then((db) => {\r\n            if (!db) return;\r\n            let tx = db.transaction('offline-favorite', 'readwrite');\r\n            let store = tx.objectStore('offline-favorite');\r\n            return store.delete(favoriteRestaurantId);\r\n        }).then(() => {\r\n            callback(null);\r\n        });\r\n    }\r\n}\r\n\r\n\r\n//try to submit offline reviews and favorite\r\nIndexDBHelper.fetchReviewOffline((error, reviews) => {\r\n    reviews.forEach((review) => {\r\n        let reviewId = review.id;\r\n        delete review.id;\r\n        DBHelper.postRestaurantReview(review, (error, review) => {\r\n            IndexDBHelper.deleteReviewOffline(reviewId);\r\n        }, false);\r\n    });\r\n});\r\n\r\nIndexDBHelper.fetchFavoriteOffline((error, favoriteRestaurants) => {\r\n    favoriteRestaurants.forEach((favoriteRestaurant) => {\r\n        DBHelper.toggleRestaurantFavorite(favoriteRestaurant.id, (error, favoriteRestaurant) => {\r\n            IndexDBHelper.deleteFavoriteOffline(favoriteRestaurant.id)\r\n        }, false);\r\n    });\r\n});","/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n\r\n\r\n\r\n    /**\r\n     * Database URL.\r\n     * Change this to restaurants.json file location on your server.\r\n     */\r\n    static get DATABASE_URL() {\r\n        //const port = location.port ? location.port : 8000 // Change this to your server port\r\n        const port = 1337; //change according to gulpfile config\r\n        //const host = location.hostname ? location.hostname : 'localhost';\r\n        const host = 'localhost';\r\n        return `http://${host}:${port}`;\r\n    }\r\n\r\n    /**\r\n     * Fetch all restaurants.\r\n     */\r\n    static fetchRestaurants(callback) {\r\n        fetch(DBHelper.DATABASE_URL + '/restaurants').then((response) => {\r\n            return response.json();\r\n        }).then((restaurants) => {\r\n            //open indexdb to cach all restaurants data\r\n            IndexDBHelper.storeRestaurants(restaurants);\r\n            callback(null, restaurants);\r\n\r\n        }).catch((ex) => {\r\n            const error = (`Request failed. Returned status of ${ex}`);\r\n            IndexDBHelper.fetchRestaurants(callback);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch a restaurant by its ID.\r\n     */\r\n    static fetchRestaurantById(id, callback) {\r\n        fetch(DBHelper.DATABASE_URL + '/restaurants/' + id).then((response) => {\r\n            return response.json();\r\n        }).then((restaurant) => {\r\n\r\n            //add restuarants object array into a variable\r\n            callback(null, restaurant);\r\n\r\n        }).catch((ex) => {\r\n            const error = (`Request failed. Returned status of ${ex}`);\r\n            IndexDBHelper.fetchRestaurantById(id, callback);\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Fetch a restaurant by its ID.\r\n     */\r\n    static toggleRestaurantFavorite(id, callback, storeForOffline = true) {\r\n        DBHelper.fetchRestaurantById(id, function (error, restaurant) {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n\r\n                //send to option the opposite of what is currently set\r\n                restaurant.is_favorite = (restaurant.is_favorite == \"false\" ? \"true\" : \"false\");\r\n                fetch(DBHelper.DATABASE_URL + '/restaurants/' + id + '/?is_favorite=' + restaurant.is_favorite, {\r\n                    method: 'POST'\r\n                }).then((response) => {\r\n                    return response.json();\r\n                }).then((restaurant) => {\r\n                    IndexDBHelper.toggleRestaurantFavorite(restaurant);\r\n                    callback(null, restaurant);\r\n                }).catch((ex) => {\r\n                    // TODO: add offline favorite to indexdb\r\n                    const error = (`Request failed. Returned status of ${ex}`);\r\n                    //get response from index db if available\r\n                    if (storeForOffline) { //if false it mean that it's an attempt to save offline favorite so there is no need to cach it again\r\n                        IndexDBHelper.toggleRestaurantFavorite(restaurant);\r\n                        IndexDBHelper.postFavoriteOffline(restaurant, callback);\r\n                    }\r\n                });\r\n            }\r\n\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Fetch restaurants by a cuisine type with proper error handling.\r\n     */\r\n    static fetchRestaurantByCuisine(cuisine, callback) {\r\n        // Fetch all restaurants  with proper error handling\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                // Filter restaurants to have only given cuisine type\r\n                const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n                callback(null, results);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch restaurants by a neighborhood with proper error handling.\r\n     */\r\n    static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n        // Fetch all restaurants\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                // Filter restaurants to have only given neighborhood\r\n                const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n                callback(null, results);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n     */\r\n    static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n        // Fetch all restaurants\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                let results = restaurants\r\n                if (cuisine != 'all') { // filter by cuisine\r\n                    results = results.filter(r => r.cuisine_type == cuisine);\r\n                }\r\n                if (neighborhood != 'all') { // filter by neighborhood\r\n                    results = results.filter(r => r.neighborhood == neighborhood);\r\n                }\r\n                callback(null, results);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch all neighborhoods with proper error handling.\r\n     */\r\n    static fetchNeighborhoods(callback) {\r\n        // Fetch all restaurants\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                // Get all neighborhoods from all restaurants\r\n                const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n                // Remove duplicates from neighborhoods\r\n                const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n                callback(null, uniqueNeighborhoods);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch all cuisines with proper error handling.\r\n     */\r\n    static fetchCuisines(callback) {\r\n        // Fetch all restaurants\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                // Get all cuisines from all restaurants\r\n                const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n                // Remove duplicates from cuisines\r\n                const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n                callback(null, uniqueCuisines);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * get a review on a restaurant\r\n     */\r\n    static fetchRestaurantReview(restaurantId, callback) {\r\n        fetch(DBHelper.DATABASE_URL + '/reviews').then((response) => {\r\n            return response.json();\r\n        }).then((reviews) => {\r\n            const restraintReviewArray = reviews.filter((review, i) => review[\"restaurant_id\"] == restaurantId)\r\n\r\n            IndexDBHelper.storeReviews(reviews);\r\n\r\n            callback(null, restraintReviewArray);\r\n        }).catch((ex) => {\r\n            const error = (`Request failed. Returned status of ${ex}`);\r\n            //get response from index db if available\r\n            IndexDBHelper.fetchReviews(restaurantId, callback);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * post a review on a restaurant\r\n     */\r\n\r\n    static postRestaurantReview(review, callback, storeForOffline = true) {\r\n        fetch(DBHelper.DATABASE_URL + '/reviews', {\r\n            method: \"POST\",\r\n            body: review,\r\n        }).then((response) => {\r\n            return response.json();\r\n        }).then((addedReview) => {\r\n            //cach reviews in indexdb\r\n            review = Object.assign(addedReview, review);\r\n            IndexDBHelper.postReview(review);\r\n            callback(null, review);\r\n        }).catch((ex) => {\r\n            const error = (`Request failed. Returned status of ${ex}`);\r\n            if (storeForOffline) {//if this token is false it means it's an attempt to submit offline review\r\n                IndexDBHelper.postReview(review);\r\n                IndexDBHelper.postReviewOffline(review, callback);\r\n\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Restaurant page URL.\r\n     */\r\n    static urlForRestaurant(restaurant) {\r\n        return (`./restaurant.html?id=${restaurant.id}`);\r\n    }\r\n\r\n    /**\r\n     * Restaurant image URL.\r\n     */\r\n    static imageUrlForRestaurant(restaurant) {\r\n        return (`/img/${restaurant.photograph}`);\r\n    }\r\n\r\n    /**\r\n     * Map marker for a restaurant.\r\n     */\r\n    static mapMarkerForRestaurant(restaurant, map) {\r\n        const marker = new google.maps.Marker({\r\n            position: restaurant.latlng,\r\n            title: restaurant.name,\r\n            url: DBHelper.urlForRestaurant(restaurant),\r\n            map: map,\r\n            animation: google.maps.Animation.DROP\r\n        });\r\n        return marker;\r\n    }\r\n\r\n}\r\n","function IndexController() {\r\n    this._registerServiceWorker();\r\n}\r\n\r\nIndexController.prototype._registerServiceWorker = function () {\r\n    if (!navigator.serviceWorker) return;\r\n\r\n    var indexController = this;\r\n\r\n    navigator.serviceWorker.register('sw.js').then(function (reg) {\r\n        if (!navigator.serviceWorker.controller) {\r\n            return;\r\n        }\r\n\r\n        if (reg.waiting) {\r\n            indexController._updateReady(reg.waiting);\r\n            return;\r\n        }\r\n\r\n        if (reg.installing) {\r\n            indexController._trackInstalling(reg.installing);\r\n            return;\r\n        }\r\n\r\n        reg.addEventListener('updatefound', function () {\r\n            indexController._trackInstalling(reg.installing);\r\n        });\r\n    });\r\n\r\n    // Ensure refresh is only called once.\r\n    // This works around a bug in \"force update on reload\".\r\n    var refreshing;\r\n    navigator.serviceWorker.addEventListener('controllerchange', function () {\r\n        if (refreshing) return;\r\n        window.location.reload();\r\n        refreshing = true;\r\n    });\r\n    navigator.serviceWorker.addEventListener('message', event => {\r\n        console.log(event.data.msg, event.data.url);\r\n    });\r\n};\r\n\r\nIndexController.prototype._trackInstalling = function (worker) {\r\n    var indexController = this;\r\n    worker.addEventListener('statechange', function () {\r\n        if (worker.state == 'installed') {\r\n            indexController._updateReady(worker);\r\n        }\r\n    });\r\n};\r\n\r\nIndexController.prototype._updateReady = function (worker) {\r\n\r\n    var toast = confirm(\"New version available, do you want to upate ?\");\r\n\r\n    if (toast != null) {\r\n        worker.postMessage({\r\n            action: 'skipWaiting'\r\n        });\r\n    }\r\n\r\n};\r\n\r\n//initialize sw\r\nlet swController = new IndexController();\r\n","let restaurants,\r\n    neighborhoods,\r\n    cuisines, map, markers = [];\r\n\r\n/**\r\n * Fetch neighborhoods and cuisines as soon as the page is loaded.\r\n */\r\ndocument.addEventListener('DOMContentLoaded', (event) => {\r\n\r\n    getAllRestaurants();\r\n    fetchNeighborhoods();\r\n    fetchCuisines();\r\n});\r\n\r\n/**\r\n * Fetch all neighborhoods and set their HTML.\r\n */\r\nconst fetchNeighborhoods = () => {\r\n    DBHelper.fetchNeighborhoods((error, neighborhoods) => {\r\n        if (error) { // Got an error\r\n            console.error(error);\r\n        } else {\r\n            self.neighborhoods = neighborhoods;\r\n            fillNeighborhoodsHTML();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Set neighborhoods HTML.\r\n */\r\nconst fillNeighborhoodsHTML = (neighborhoods = self.neighborhoods) => {\r\n    const select = document.getElementById('neighborhoods-select');\r\n    neighborhoods.forEach(neighborhood => {\r\n        const option = document.createElement('option');\r\n        option.innerHTML = neighborhood;\r\n        option.value = neighborhood;\r\n        select.append(option);\r\n    });\r\n}\r\n\r\n/**\r\n * Fetch all cuisines and set their HTML.\r\n */\r\nconst fetchCuisines = () => {\r\n    DBHelper.fetchCuisines((error, cuisines) => {\r\n        if (error) { // Got an error!\r\n            console.error(error);\r\n        } else {\r\n            self.cuisines = cuisines;\r\n            fillCuisinesHTML();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Set cuisines HTML.\r\n */\r\nconst fillCuisinesHTML = (cuisines = self.cuisines) => {\r\n    const select = document.getElementById('cuisines-select');\r\n\r\n    cuisines.forEach(cuisine => {\r\n        const option = document.createElement('option');\r\n        option.innerHTML = cuisine;\r\n        option.value = cuisine;\r\n        select.append(option);\r\n    });\r\n}\r\n\r\n/**\r\n * Initialize Google map, called from HTML.\r\n */\r\nfunction initMap() {\r\n    let loc = {\r\n        lat: 40.722216,\r\n        lng: -73.987501\r\n    };\r\n    if (!self.map) {\r\n        self.map = new google.maps.Map(document.getElementById('map'), {\r\n            zoom: 12,\r\n            center: loc,\r\n            scrollwheel: false\r\n        });\r\n    }\r\n\r\n    document.getElementById(\"map-container\").classList.add(\"show-interactive-map\");\r\n    //set markers on the map\r\n    addMarkersToMap();\r\n}\r\n\r\nconst initStaticMap = () => {\r\n    let latlng = \"40.722216,-73.987501\",\r\n        zoom = 12,\r\n        imageConrtainer = document.getElementById(\"map-container\");\r\n    let size = imageConrtainer.offsetWidth + \"x\" + imageConrtainer.offsetHeight;\r\n    let staticMapURL = `https://maps.googleapis.com/maps/api/staticmap?center=${latlng}&zoom=${zoom}&size=${size}&key=AIzaSyD7zwXocDxCO_YLSyVhDNYZDmhMxr0RcNU`;\r\n    restaurants.forEach((restaurant) => {\r\n        staticMapURL += `&markers=${restaurant.latlng.lat},${restaurant.latlng.lng}` ;\r\n    });\r\n    document.querySelector(\".static-map\").setAttribute(\"src\", staticMapURL);\r\n}\r\nconst getAllRestaurants = () => {\r\n    DBHelper.fetchRestaurantByCuisineAndNeighborhood(\"all\", \"all\", (error, restaurants) => {\r\n        if (error) { // Got an error!\r\n            console.error(error);\r\n        } else {\r\n            resetRestaurants(restaurants);\r\n            fillRestaurantsHTML();\r\n            initStaticMap();\r\n        }\r\n    })\r\n}\r\n/**\r\n * Update page and map for current restaurants.\r\n */\r\nconst updateRestaurants = () => {\r\n    const cSelect = document.getElementById('cuisines-select');\r\n    const nSelect = document.getElementById('neighborhoods-select');\r\n    //get slected option value\r\n    const cuisine = cSelect[cSelect.selectedIndex].value;\r\n    const neighborhood = nSelect[nSelect.selectedIndex].value;\r\n\r\n    DBHelper.fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, (error, restaurants) => {\r\n        if (error) { // Got an error!\r\n            console.error(error);\r\n        } else {\r\n            resetRestaurants(restaurants);\r\n            fillRestaurantsHTML();\r\n            initMap();\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * Clear current restaurants, their HTML and remove their map markers.\r\n */\r\nconst resetRestaurants = (restaurants) => {\r\n    // Remove all restaurants\r\n    self.restaurants = [];\r\n    const ul = document.getElementById('restaurants-list');\r\n    ul.innerHTML = '';\r\n\r\n    // Remove all map markers\r\n    self.markers.forEach(m => m.setMap(null));\r\n    self.markers = [];\r\n    self.restaurants = restaurants;\r\n}\r\n\r\n/**\r\n * Create all restaurants HTML and add them to the webpage.\r\n */\r\nconst fillRestaurantsHTML = (restaurants = self.restaurants) => {\r\n    const ul = document.getElementById('restaurants-list');\r\n    restaurants.forEach(restaurant => {\r\n        ul.append(createRestaurantHTML(restaurant));\r\n    });\r\n\r\n    //now we have to fill the static image first\r\n    //addMarkersToMap();\r\n    //init lazy loading\r\n    setTimeout(function () {\r\n        bLazy.revalidate();\r\n    }, 10);\r\n}\r\n\r\n/**\r\n * Create restaurant HTML.\r\n */\r\nconst createRestaurantHTML = (restaurant) => {\r\n    const li = document.createElement('li');\r\n    li.setAttribute(\"role\", \"listitem\")\r\n\r\n    const image = document.createElement('img');\r\n    const imageSrc = DBHelper.imageUrlForRestaurant(restaurant);\r\n    image.className = 'restaurant-img b-lazy';\r\n    image.src = \"/img/placeholder-image.jpg\";\r\n    image.setAttribute(\"data-src\", `${imageSrc}`);\r\n    image.setAttribute(\"data-srcset\", `/img/${restaurant.id}_300.jpg 300w,/img/${restaurant.id}.jpg 586w,/img/${restaurant.id}_800.jpg 800w`);\r\n    image.alt = restaurant.name;\r\n    const picture = document.createElement('picture');\r\n    picture.append(image);\r\n    li.append(picture);\r\n    const dataContainer = document.createElement('article');\r\n    li.append(dataContainer);\r\n    const name = document.createElement('a');\r\n    name.innerHTML = restaurant.name;\r\n    name.href = DBHelper.urlForRestaurant(restaurant);\r\n    dataContainer.append(name);\r\n\r\n    const neighborhood = document.createElement('p');\r\n    neighborhood.setAttribute(\"title\", \"Neighborhood\");\r\n    neighborhood.innerHTML = restaurant.neighborhood;\r\n    dataContainer.append(neighborhood);\r\n\r\n    const address = document.createElement('address');\r\n    address.innerHTML = restaurant.address;\r\n    dataContainer.append(address);\r\n\r\n    const more = document.createElement('a');\r\n    more.innerHTML = 'View Details';\r\n    more.classList.add(\"more\");\r\n    more.setAttribute(\"role\", \"button\");\r\n    more.href = DBHelper.urlForRestaurant(restaurant);\r\n    dataContainer.append(more);\r\n\r\n    const addTofavoriteButton = document.createElement(\"button\");\r\n   \r\n    addTofavoriteButton.classList.add(\"add-tofavorite\");\r\n    if(restaurant.is_favorite == \"true\" || restaurant.is_favorite == true){\r\n        addTofavoriteButton.classList.add(\"favorite\");\r\n        addTofavoriteButton.innerHTML = '<span>★</span> Favorited';\r\n        addTofavoriteButton.title = \"Click to remove from favorite\";\r\n    }\r\n    else{\r\n         addTofavoriteButton.innerHTML = '<span>☆</span> Add To Favorite';\r\n    }\r\n    addTofavoriteButton.setAttribute(\"role\", \"button\");\r\n    addTofavoriteButton.setAttribute(\"onclick\",\"addRestaurantToFavorite(this)\");\r\n    addTofavoriteButton.dataset.restaurantId = restaurant.id;\r\n    dataContainer.append(addTofavoriteButton);\r\n\r\n    return li;\r\n}\r\n\r\n/**\r\n * Add retaurant to favorite.\r\n */\r\nconst addRestaurantToFavorite = (btn) =>{\r\n    DBHelper.toggleRestaurantFavorite(btn.dataset['restaurantId'],function(error,response){\r\n        if(error) alert(error);\r\n        if(response.is_favorite == \"false\"){\r\n            btn.classList.remove(\"favorite\");\r\n            btn.innerHTML = '<span>☆</span> Add To Favorite';\r\n        }else{\r\n            btn.innerHTML = '<span>★</span> Favorited';\r\n            btn.title = \"Click to remove from favorite\";\r\n            btn.classList.add(\"favorite\");\r\n        }\r\n    });\r\n}\r\n\r\n/**                                                                                                                                                                                                                                                                                                                                                                                                             \r\n * Add markers for current restaurants to the map.\r\n */\r\nconst addMarkersToMap = (restaurants = self.restaurants) => {\r\n    restaurants.forEach(restaurant => {\r\n        // Add marker to the map\r\n        const marker = DBHelper.mapMarkerForRestaurant(restaurant, self.map);\r\n        google.maps.event.addListener(marker, 'click', () => {\r\n            window.location.href = marker.url\r\n        });\r\n        self.markers.push(marker);\r\n    });\r\n}\r\n\r\n/*change aria expanded value*/\r\nconst changeAriaValue = (that) => {\r\n    that.getAttribute(\"aria-expanded\") == \"true\" ? that.setAttribute(\"aria-expanded\", \"false\") : that.setAttribute(\"aria-expanded\", \"true\");\r\n}\r\n\r\n\r\n\r\nconst bLazy = new Blazy({\r\n    // Options\r\n});\r\n"]}